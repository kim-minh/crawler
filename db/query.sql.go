// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createCompany = `-- name: CreateCompany :exec
INSERT INTO companies (
    fullname_vi, company_type, exchange, ticker
) VALUES (
    $1, $2, $3, $4
) ON CONFLICT (ticker) DO UPDATE
SET (fullname_vi, company_type, exchange)
= ($1, $2, $3)
`

type CreateCompanyParams struct {
	FullnameVi  pgtype.Text
	CompanyType pgtype.Int4
	Exchange    pgtype.Text
	Ticker      string
}

func (q *Queries) CreateCompany(ctx context.Context, arg CreateCompanyParams) error {
	_, err := q.db.Exec(ctx, createCompany,
		arg.FullnameVi,
		arg.CompanyType,
		arg.Exchange,
		arg.Ticker,
	)
	return err
}

const createEvent = `-- name: CreateEvent :exec
INSERT INTO events (
id,
company_id,
price,
price_change,
price_change_ratio,
monthly_price_change_ratio,
ex_rights_date,
exercise_date,
notify_date ,
registration_final_date,
event_code,
event_name,
event_description,
rsi,
rs
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15)
`

type CreateEventParams struct {
	ID                      int32
	CompanyID               int32
	Price                   pgtype.Int4
	PriceChange             pgtype.Int4
	PriceChangeRatio        pgtype.Float4
	MonthlyPriceChangeRatio pgtype.Float4
	ExRightsDate            pgtype.Timestamptz
	ExerciseDate            pgtype.Timestamptz
	NotifyDate              pgtype.Timestamptz
	RegistrationFinalDate   pgtype.Timestamptz
	EventCode               pgtype.Text
	EventName               pgtype.Text
	EventDescription        pgtype.Text
	Rsi                     pgtype.Float4
	Rs                      pgtype.Float4
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) error {
	_, err := q.db.Exec(ctx, createEvent,
		arg.ID,
		arg.CompanyID,
		arg.Price,
		arg.PriceChange,
		arg.PriceChangeRatio,
		arg.MonthlyPriceChangeRatio,
		arg.ExRightsDate,
		arg.ExerciseDate,
		arg.NotifyDate,
		arg.RegistrationFinalDate,
		arg.EventCode,
		arg.EventName,
		arg.EventDescription,
		arg.Rsi,
		arg.Rs,
	)
	return err
}

const createInsiderDeal = `-- name: CreateInsiderDeal :exec
INSERT INTO insider_deals (
    company_id,
    deal_price,
    deal_quantity,
    deal_ratio,
    deal_announce_date,
    deal_action,
    deal_method
) VALUES ($1, $2, $3, $4, $5, $6, $7)
`

type CreateInsiderDealParams struct {
	CompanyID        int32
	DealPrice        pgtype.Int4
	DealQuantity     pgtype.Int4
	DealRatio        pgtype.Float4
	DealAnnounceDate pgtype.Timestamptz
	DealAction       pgtype.Text
	DealMethod       pgtype.Text
}

func (q *Queries) CreateInsiderDeal(ctx context.Context, arg CreateInsiderDealParams) error {
	_, err := q.db.Exec(ctx, createInsiderDeal,
		arg.CompanyID,
		arg.DealPrice,
		arg.DealQuantity,
		arg.DealRatio,
		arg.DealAnnounceDate,
		arg.DealAction,
		arg.DealMethod,
	)
	return err
}

const createOfficer = `-- name: CreateOfficer :exec
INSERT INTO officers (
    no,
    company_id,
    own_percent,
    name,
    position
) VALUES ($1, $2, $3, $4, $5)
ON CONFLICT (no, company_id) DO UPDATE
SET (
own_percent,
    name,
    position
) = ($3, $4, $5)
`

type CreateOfficerParams struct {
	No         int32
	CompanyID  int32
	OwnPercent pgtype.Float4
	Name       pgtype.Text
	Position   pgtype.Text
}

func (q *Queries) CreateOfficer(ctx context.Context, arg CreateOfficerParams) error {
	_, err := q.db.Exec(ctx, createOfficer,
		arg.No,
		arg.CompanyID,
		arg.OwnPercent,
		arg.Name,
		arg.Position,
	)
	return err
}

const createOverview = `-- name: CreateOverview :exec
INSERT INTO overview (
    company_id,
    delta_in_month,
    delta_in_week,
    delta_in_year,
    established_year,
    foreign_percent,
    industry_id,
    industry_id_v2,
    issue_share,
    number_of_employees,
    number_of_shareholders,
    outstanding_share,
    stock_rating,
    company_type,
    exchange,
    industry,
    industry_en,
    short_name,
    website
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19
) ON CONFLICT (company_id) DO UPDATE
SET (
    delta_in_month,
    delta_in_week,
    delta_in_year,
    established_year,
    foreign_percent,
    industry_id,
    industry_id_v2,
    issue_share,
    number_of_employees,
    number_of_shareholders,
    outstanding_share,
    stock_rating,
    company_type,
    exchange,
    industry,
    industry_en,
    short_name,
    website
) = ($2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19)
`

type CreateOverviewParams struct {
	CompanyID            int32
	DeltaInMonth         pgtype.Float4
	DeltaInWeek          pgtype.Float4
	DeltaInYear          pgtype.Float4
	EstablishedYear      pgtype.Int2
	ForeignPercent       pgtype.Float4
	IndustryID           pgtype.Int4
	IndustryIDV2         pgtype.Int4
	IssueShare           pgtype.Float4
	NumberOfEmployees    pgtype.Int4
	NumberOfShareholders pgtype.Int4
	OutstandingShare     pgtype.Float4
	StockRating          pgtype.Float4
	CompanyType          pgtype.Text
	Exchange             pgtype.Text
	Industry             pgtype.Text
	IndustryEn           pgtype.Text
	ShortName            pgtype.Text
	Website              pgtype.Text
}

func (q *Queries) CreateOverview(ctx context.Context, arg CreateOverviewParams) error {
	_, err := q.db.Exec(ctx, createOverview,
		arg.CompanyID,
		arg.DeltaInMonth,
		arg.DeltaInWeek,
		arg.DeltaInYear,
		arg.EstablishedYear,
		arg.ForeignPercent,
		arg.IndustryID,
		arg.IndustryIDV2,
		arg.IssueShare,
		arg.NumberOfEmployees,
		arg.NumberOfShareholders,
		arg.OutstandingShare,
		arg.StockRating,
		arg.CompanyType,
		arg.Exchange,
		arg.Industry,
		arg.IndustryEn,
		arg.ShortName,
		arg.Website,
	)
	return err
}

const createProfile = `-- name: CreateProfile :exec
INSERT INTO profile (
    company_id,
    business_risk,
    business_strategies,
    company_name,
    history_dev,
    key_developments,
    profile,
    promise
) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
ON CONFLICT (company_id) DO UPDATE
SET (
    business_risk,
    business_strategies,
    company_name,
    history_dev,
    key_developments,
    profile,
    promise
) = ($2, $3, $4, $5, $6, $7, $8)
`

type CreateProfileParams struct {
	CompanyID          int32
	BusinessRisk       pgtype.Text
	BusinessStrategies pgtype.Text
	CompanyName        pgtype.Text
	HistoryDev         pgtype.Text
	KeyDevelopments    pgtype.Text
	Profile            pgtype.Text
	Promise            pgtype.Text
}

func (q *Queries) CreateProfile(ctx context.Context, arg CreateProfileParams) error {
	_, err := q.db.Exec(ctx, createProfile,
		arg.CompanyID,
		arg.BusinessRisk,
		arg.BusinessStrategies,
		arg.CompanyName,
		arg.HistoryDev,
		arg.KeyDevelopments,
		arg.Profile,
		arg.Promise,
	)
	return err
}

const createShareholder = `-- name: CreateShareholder :exec
INSERT INTO large_shareholders (
    no,
    company_id,
    share_own_percent,
    shareholder
) VALUES ($1, $2, $3, $4)
ON CONFLICT (no, company_id) DO UPDATE
SET (
    share_own_percent,
    shareholder
) = ($3, $4)
`

type CreateShareholderParams struct {
	No              int32
	CompanyID       int32
	ShareOwnPercent pgtype.Float4
	Shareholder     pgtype.Text
}

func (q *Queries) CreateShareholder(ctx context.Context, arg CreateShareholderParams) error {
	_, err := q.db.Exec(ctx, createShareholder,
		arg.No,
		arg.CompanyID,
		arg.ShareOwnPercent,
		arg.Shareholder,
	)
	return err
}

const createSubsidiary = `-- name: CreateSubsidiary :exec
INSERT INTO subsidiaries (
    no,
    company_id,
    own_percent,
    name
) VALUES ($1, $2, $3, $4)
ON CONFLICT (no, company_id) DO UPDATE
SET (
    own_percent,
    name
) = ($3, $4)
`

type CreateSubsidiaryParams struct {
	No         int32
	CompanyID  int32
	OwnPercent pgtype.Float4
	Name       pgtype.Text
}

func (q *Queries) CreateSubsidiary(ctx context.Context, arg CreateSubsidiaryParams) error {
	_, err := q.db.Exec(ctx, createSubsidiary,
		arg.No,
		arg.CompanyID,
		arg.OwnPercent,
		arg.Name,
	)
	return err
}

const listCompanies = `-- name: ListCompanies :many
SELECT id, fullname_vi, company_type, exchange, ticker FROM companies
`

func (q *Queries) ListCompanies(ctx context.Context) ([]Company, error) {
	rows, err := q.db.Query(ctx, listCompanies)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Company
	for rows.Next() {
		var i Company
		if err := rows.Scan(
			&i.ID,
			&i.FullnameVi,
			&i.CompanyType,
			&i.Exchange,
			&i.Ticker,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
